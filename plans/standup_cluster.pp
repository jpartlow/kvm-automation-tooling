# Standup one cluster of KVM virtual machines for a particular OS Puppet
# architecture.
#
# Makes use of terraform under the hood for vm initialization.
#
# @param $cluster_name This is combined with *architecture*, *os*,
# *os_version*, *os_arch* to obtain a reasonably unique id for the cluster.
# The *cluster_name* allows you to stand up more than one cluster of the
# same architecture and platform, for example.
# @param $architecture The Puppet services architecture of the cluster (see
# docs/ARCHITECTURE.md).
# @param $os The base operating system of the cluster.
# @param $os_version The version of the base operating system of the
# cluster.
# @param $os_arch The chip architecture of the base operating system of the
# cluster.
# @param $agents The number of Puppet agent vms to stand up in the cluster.
# @param $primary_cpus The number of CPUs to allocate to the primary vm.
# @param $primary_mem_mb The amount of memory in MB to allocate to the primary
# vm.
# @param $primary_disk_gb The amount of disk space in GB to allocate to the
# primary vm.
# @param $agent_cpus The number of CPUs to allocate to each agent vm.
# @param $agent_mem_mb The amount of memory in MB to allocate to each agent vm.
# @param $agent_disk_gb The amount of disk space in GB to allocate to each
# agent vm.
# @param $image_download_dir The directory where base os images are downloaded to.
# @param $libvirt_images_dir The default directory where libvirt images are
# stored (this is the default pool, and shouldn't be changed unless your
# libvirt has a different local structure).
plan kvm_automation_tooling::standup_cluster(
  String $cluster_name,
  String $user = system::env('USER'),
  Kvm_automation_tooling::Architectures $architecture = 'singular',
  Kvm_automation_tooling::Operating_systems $os,
  Kvm_automation_tooling::Version $os_version,
  Kvm_automation_tooling::Os_arch $os_arch,
  Integer $agents = 1,
  Integer $primary_cpus = 4,
  Integer $primary_mem_mb = 8192,
  Integer $primary_disk_gb = 20,
  Integer $agent_cpus = 1,
  Integer $agent_mem_mb = 512,
  Integer $agent_disk_gb = 10,
  String $image_download_dir = '~/images',
  String $libvirt_images_dir = '/var/lib/libvirt/images',
) {
  $platform = kvm_automation_tooling::platform($os, $os_version, $os_arch)
  $cluster_id = "${cluster_name}-${architecture}-${platform}"
  $primary_hostname = "${cluster_id}-primary"
  $agent_hostnames = $agents.map |$i| { "${cluster_id}-agent-${i}" }
  $tfvars_file = "./terraform/instances/${cluster_id}.tfvars.json"
  $tfstate_file = "./terraform/instances/${cluster_id}.tfstate"

  # Ensure base image volume is present.
  $base_volume_name = "${platform}.qcow2"
  $base_volume_path = "${libvirt_images_dir}/${base_volume_name}"
  $base_volume_found_result = run_command("test -f ${base_volume_path}", 'localhost')
  if !$base_volume_found_result.ok() {
    $image_url = kvm_automation_tooling::get_image_url($platform)
    $image_name = $base_image_url.split('/')[-1]
    $image_path = "${image_download_dir}/${image_name}"

    $download_image_found_result = run_command("test -f ${image_path}", 'localhost')
    if !$download_image_found_result.ok() {
      run_command("curl -L -o ${image_download_dir} ${image_url}", 'localhost')
    }
    run_command("virsh vol-download --pool default --vol ${base_volume_name} --file ${image_path}", 'localhost')
  }

  # Ensure platform image pool exists.


  # Write tfvars.json file.
  file::write($tfvars_file, to_json({
    # TODO: this list was generated by copilot and needs to be reviewed. 
    cluster_id => $cluster_id,
    primary_hostname => $primary_hostname,
    agent_hostnames => $agent_hostnames,
    primary_cpus => $primary_cpus,
    primary_mem_mb => $primary_mem_mb,
    primary_disk_gb => $primary_disk_gb,
    agent_cpus => $agent_cpus,
    agent_mem_mb => $agent_mem_mb,
    agent_disk_gb => $agent_disk_gb,
    user => $user,
  }))

  # Terraform apply.
  run_plan('terraform::apply', 'vars_file' => $tfvars_file, 'state' => $tfstate_file)
}
